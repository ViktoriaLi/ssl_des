1. Считывание инпута - сделать с новой строки каждый ввод
2. OpenSSL base64 puts a newline character after every 64 characters.
You must be able to parse the whitespace.  Recreating it is optional.
если нет ключа, а есть другой флаг, надо его отклонять?
дописать в бейс64  & 254
если месседж длиннее 6 байт, почему то выводит флаги
сделать обнуление массивов где нужно
сделать проверку на невалидные файлы
сделать ожидание чтени из инпута
Все зафришить
сделать ноупад дополнение 8 если считано кратное 8 количество байт (еще 8 08 в 16 системе)
бейс64 - ставить новую строку после каждых 64 байт исходного текста, учитывать ее при дешифровке
для дешифровки бейс64 читать по 64-65 чтоб игнорировать пустую строку
для дес -а - учитывать, что нужно брать по 3 -4 байта, тоесть надо сохранять пред вывод, и читать по количеству кратному 3-4 байт
предусмотреть некоректные флаги и аргументы (которые не предусмотрены для конкретного шифра)
Реализовать расшифровку, чтение большими блоками
в какиех то случаях вконце вывода процент
наверное надо убрать заглушку на новую строку в открытом тексте
сделать подстановку кодичества недостающих байт не нолями, а цифрой
в десе выводится без новой строки
бейс64 разный вывод при декрипшене длинного текста
с инпута перестало выдавать больше  ответа
игнорировать паддинг при декрипшене и добавить 8байтовый паддинг, особенно если считано ровно 48 байт и это весь текст
бесконечный цикл если больше / меньше 8 байт сообщение в дес
моет ошибка в добавлении паддинга


m = 1 35 69 103 137 171 205 239+
m first shift = 204 0 204 255 240 170 240 170+

right E 48 = 122 21 85 122 21 85+
right after XOR 48 = 97 23 186 134 101 39+
right after XOR 64 = 24 17 30 58 33 38 20 39!!!+
s output = 5 12 8 2 11 5 9 7+
right after XOR S = 92 130 181 151+
right after P permutation = 35 74 169 187 +
left after XOR = 239 74 101 68
left 16 = 67 66 50 52
right 16 = 10 76 217 149

k64 = 19 52 87 121 155 188 223 241+
k56 = 240 204 170 245 86 103 143+
k1 shift = 225 153 85 250 172 207 30+
k2 shift = 195 50 171 245 89 158 61+
k3 shift = 12 202 175 245 102 120 245+
k16 shift = 240 204 170 245 86 103 143+
kf1 = 27 2 239 252 112 114+
kf16 = 203 61 139 14 23 245+

res64 bits after shift = 133 232 19 84 15 10 180 5

Example 2 http://bit.nmu.org.ua/ua/student/metod/cryptology/лекция%206.pdf
m = 18 52 86 171 205 19 37 54+
m first shift = 20 167 214 120 24 202 24 173
r1 = 90 120 227 148+
l1 = 24 202 24 173
r2 = 74 18 16 246
l2 = 90 120 227 148+
r3 = 184 8 149 145
l3 = 74 18 16 246

r16 = 207 38 180 114
l16 = 25 186 146 18

k1 = 25 76 208 114 222 140
k2 = 69 104 88 26 188 206
k16 = 24 28 93 117 198 109

res64 bits after shift = 192 183 168 208 95 58 130 156

decryption
k1 = 24 28 93 117 198 109
k2 = 51 48 197 217 163 109
k15 =
k16 = 25 76 208 114 222 140
m = 192 183 168 208 95 58 130 156


L1 = R0
R1 = L0 + f(R0 , K1 )

L2 = R1
R2 = L1 + f(R1 , K2 )

L3 = R2
R3 = L2 + f(R2 , K3 )


example 3 cbc http://studbooks.net/2009665/informatika/rezhim#41
